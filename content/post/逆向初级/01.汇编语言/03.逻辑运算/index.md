---
title: "03.逻辑运算"
date: 2025-08-30
categories: ["逆向初级","汇编基础"]
---

# 逻辑运算的引入

如果现在只是将数据存到计算机的容器中，是没有任何意义的，我们还需要告诉计算机这些数据有什么用，让计算机对这些数做运算。所以我们知道计算机到底是如何做运算的，所以我们引入逻辑运算

# 逻辑运算

由于计算机受硬件的限制影响，CPU再复杂可以理解为一条条的线路组成的，而电信号只有两种形式0和1，所以一般计算机的逻辑运算的对象都是二进制数

逻辑运算分为：
| 逻辑运算 | 汇编符号 | C语言符号 | 口诀               |
| -------- | -------- | --------- | ------------------ |
| 与       | `AND`    | `&`       | 有0则0，全1才1     |
| 或       | `OR`     | `|`       | 有1则1，全0才0     |
| 异或     | `XOR`    | `^`       | 相同为0，相异为1   |
| 非       | `NOT`    | `!` 或 `~`| 0变1，1变0         |



### CPU是如何计算2+3

1. **初始数据**（二进制表示）

`x = 2`，二进制表示：`0010`
`y = 3`，二进制表示：`0011`

```
	0010	
xor 0011
------------
	0001        R:0001
	
	0010
and 0011
------------
	0010  <<1  得   0100       #<<1表示左移一位
	
此时计算机会判断0100是否全为0,如果全为0表示运算结束,将R中此时的值作为结果输出,如果不为0则将R中的值赋给x。0100赋给y再做一次同样运算

	0001
xor 0100
-------------
	0101         R:0101
	
	0001
and 0100
-------------
	0000  <<1  得   0000

判断0000全为0,则运算结束,将R中的值0101作为运算的结果,化成十进制即为5
```
总结

这个过程模拟了 **加法运算**，通过 **XOR** 来计算和，使用 **AND** 来计算进位，然后通过 **左移** 来处理进位，最终得到结果 `5`。

### 计算3-2
x = 3` → 二进制：`0000 0011
y = 2` → 二进制：`0000 0010

`-2` 的补码：

- 原码：`0000 0010`
- 反码：`1111 1101`
- 补码：`1111 1110`

```


补码0000 0010->1111 1101->1111 1110

##############第一次运算
0000 0011
1111 1110  xor
----------
1111 1101   R:1111 1101


0000 0011
1111 1110  and
----------
0000 0100   <<进位1 得0000 0100

更新变量：  
x = 1111 1101
y = 0000 0100

##############第二次运算
1111 1101
0000 0100  xor
----------
1111 1001   R:1111 1001

1111 1101
0000 0100  and
----------
0000 0100    <<进位1 得0000 1000
更新变量：  
x = 1111 1001
y = 0000 1000

###############第三次运算
1111 1001
0000 1000 xor
-------------
1111 0001     R:1111 0001


1111 1001
0000 1000 and
--------------
0000 1000    进位0001 0000

更新变量：  
x = 1111 0001
y = 0001 0000

############第四次运算
1111 0001
0001 0000 xor
-------------
1110 0001    R:1110 0001


1111 0001
0001 0000 and
-------------
0001 0000    进位0010 0000

更新变量：  
x = 1110 0001
y = 0010 0000

############第五次运算
1110 0001
0010 0000 xor
-------------
1100 0001    R:1100 0001

1110 0001
0010 0000 and
-------------
0010 0001    进位0100 0001

更新变量：  
x = 1100 0001
y = 0100 0001

############第六次运算
1100 0001
0100 0001 xor
-------------
1000 0001    R:1000 0001


1100 0001
0100 0001 and
-------------
0100 0001    进位1000 0001

更新变量：  
x = 1000 0001
y = 1000 0001

#########第七次运算
1000 0001
1000 0001 xor
-------------
0000 0000    R:1000 0001

1000 0001
1000 0001 and
-------------
0000 0000   进位00000 0000


```

### 计算2-3

`x=2 y=3 `

```
0000 0010
1111 1101  xor
-------------
1111 1111


0000 0010
1111 1101 and
-------------
0000 0000

1111 1111
取反 → 加1 → 得正数 → 加负号
0000 0000 
0000 0001
-1
```



## 如何获取某个值的第N位是0还是1

比如现在某个寄存器中存了一个值，值化成二进制时，有些特殊的值每一位都有它的特殊含义，所以我们想要知道这个值的第N位是0还是1。如果我们把寄存器中的值取出来，一个一个数着看，就会很麻烦，但是如果做下面的运算，就会容易很多

#现在想要查看某寄存器中的值的第4位是0还是1,我们就可以将寄存器中的值与0x08做与运算，如果得到结果中有一个1,则这个值的第四位就是1，如果结果全是0，则值的第四位就是0

```
		10001111
and		00001000
​		00001000


```



## 用异或做加密解密

如果进行简单的加密，可以使用亦[或运算](https://so.csdn.net/so/search?q=或运算&spm=1001.2101.3001.7020)，因为选择一个双方都知道密钥，用此密钥与数据做亦或加密加密过后，别人如果没有密钥则不好解开这个密文，而对于接受方，使用相同的密钥再做一次亦或即可得到原来的明文值

```
要加密的数据:2015			00100000		00010101
		         	 ^	01010100	 ^	01010100
		         	 ------------    ------------
密钥:54				   01110100		   01000001
					
加密后的结果：			      74		       41
					
					
                         01110100	   01000001
                      ^	01010100	 ^  01010100
		         	-------------     ------------
						00100000		00010101
					
解密后的结果：				  20		       15

```

