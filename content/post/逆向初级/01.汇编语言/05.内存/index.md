---
title: "05.内存"
date: 2025-09-03
categories: ["逆向初级","汇编基础"]
---
# CPU 的“位”

## 32 位指的是什么？

- **CPU 的位数** = **寄存器宽度 + ALU 运算位宽 + 地址总线宽度**
  - **寄存器宽度 = 32 位** → 每个寄存器能存 4 字节数据
  - **ALU = 32 位** → 一次运算处理 32 位数据
  - **地址总线 = 32 位** → 可寻址空间 = 2³² 字节 = 4GB

✅ 关键点：**“32 位”不是随便说的，而是 CPU 各个核心部件设计的一致结果。**

- **寄存器宽度** → 决定数据存储/运算能力
- **地址总线宽度** → 决定最大内存寻址范围
- **ALU 宽度** → 决定一次能处理多少位的数据

## CPU 操作寄存器与内存的区别

### CPU 访问寄存器的方式
- **位置**：CPU 内部的小型高速存储
- **存的是什么**：数据本身（整数、浮点数、指针等）
- **访问方式**：直接访问
  - 例：`MOV EAX, 5` → EAX 直接存储数值 5（32 位）
- **特点**：容量小、速度最快

### CPU 访问内存的方式

- **位置**：CPU 外部的大容量存储

- **存的是什么**：数据（通过地址编号访问）

- **访问方式**：必须先通过地址才能读写  
  - 例：`MOV EAX, [0x1000]` → CPU 按地址 0x1000 取数据到 EAX

**CPU 内存寻址规则**

- **地址总线宽度**：32 位 → 可表示 2³² 个不同的地址编号

- **最小寻址单位**：1 个地址编号对应 **1 字节（8 位）**

- **最大寻址范围**：2³² × 1B = **4GB**

- **关键点**：
  - CPU 访问的是 **地址编号**，而不是数据本身
  - 数据必须通过地址读取到寄存器或 ALU 才能操作


### 对比总结

| 存储位置 | 存储内容         | 访问方式                 | 特点          |
| -------- | ---------------- | ------------------------ | ------------- |
| 寄存器   | 数据本身         | 直接读写                 | 极快，数量少  |
| 内存     | 数据（地址定位） | 先通过地址寻址再取/存     | 容量大，速度慢 |



### 类比记忆

- **寄存器 = 手里的小盒子**  
  - 直接装数据，随取随用  
- **内存 = 仓库**  
  - 需要地址（门牌号）才能去取东西  
  - 寄存器可以先装一个地址，再让 CPU 按地址访问仓库  



### 核心结论
1. **寄存器宽度 = CPU 位数**，决定一次能存多少数据（32 位 = 4 字节）。
2. **地址总线宽度 = CPU 位数**，决定最大可寻址内存（32 位 = 4GB）。
3. **寄存器存的是数据**，**内存是通过地址访问的数据**。
4. CPU 运行时往往是：**寄存器里存放一个地址 → 再去内存取数据**。


# 内存

每个应用程序都会有自己的独立 **4GB 内存空间**。  
> 注意：这里的“内存”指的是程序可用的虚拟内存空间，而不是物理内存条。

---

## 内存与寄存器的区别

- **寄存器**  
  - CPU 内部的小型高速存储  
  - 数量有限、造价高  
  - 可以给每个寄存器取名字（例如 EAX、EBX）  

- **内存**  
  - 外部大容量存储  
  - 太大无法命名，因此使用 **编号**  
  - 编号称为 **内存地址**  

## CPU 访问内存的数据单位

- **内存地址宽度**：32 位 → 地址编号由 32 个二进制位表示  
  
  - 一般使用 **16 进制表示**，例如：`0x00000000`  
- **最小寻址单位**：1 个地址对应 1 字节（8 位）  
- **程序可访问内存范围**：0x00000000 ~ 0xFFFFFFFF  
- **可存储的位数计算**：
  - 总块数 = 0xFFFFFFFF + 1（加 1 是因为编号从 0 开始）  
  - 每块 1 字节 = 8 位  
  - 总位数 = (0xFFFFFFFF + 1) × 8  
  - 换算为容量：
    ```text
    34359738368 Bit ÷ 8 = 4294967296 Byte
    4294967296 Byte ÷ 1024 = 4194304 KB
    4194304 KB ÷ 1024 = 4096 MB
    4096 MB ÷ 1024 = 4 GB
    ```
- ✅ 因此，每个程序都有独立的 **4GB 虚拟内存空间**。

## 寄存器与内存的区别

### 基本特点

- **寄存器**
  - 位于 CPU 内部，高速执行
  - 数量有限、造价高
  - 可以命名（如 EAX、BX、AH 等）

- **内存**
  - 外部大容量存储，速度相对较慢
  - 成本低，可以做得很大
  - 数量庞大，无法逐个命名，只能用编号（地址）代替

- **共同点**
  - 都是存储数据的容器
  - 都是定宽的（都有最大存储范围）

### 计量单位

计算机常用

- **BYTE（字节）** = 8 bit  
- **WORD（字）** = 16 bit  
- **DWORD（双字）** = 32 bit  

生活中常用

- 1 KB = 1024 Byte  
- 1 MB = 1024 KB  
- 1 GB = 1024 MB  

### 32 位 / 64 位计算机的含义

- **误区**：不是说 32 位 CPU 寄存器或内存最大宽度是 32 bit  
- **正确理解**：
  - CPU 的位数主要指 **最大寻址范围**
  - CPU 中可能存在大于 32 位的寄存器，但寻址时地址不能超过 32 位
  - CPU 通过地址编号找到内存或寄存器中的数据

### 内存编号与地址

- **寄存器命名**：数量少，可以取名字  
- **内存编号**：数量庞大，无法命名，用编号表示 → 这就是 **内存地址**

编号生成原理

- 32 位地址线 = 32 根线路，每根线 0 或 1  
- 32 根线的组合可表示 2³² 个编号  
- 每个编号对应 **1 字节（8 位）**  
- 通过编号 CPU 可以找到对应的内存单元

### 32 位地址表示

- 用 **16 进制** 表示：8 位十六进制数，如 `0x00000000` ~ `0xFFFFFFFF`  
- 每个地址编号对应 **1 字节（8 位）**

可寻址内存计算

- 地址总数：`0xFFFFFFFF - 0x00000000 + 1 = 0x100000000`  
- 转换为十进制：`2^32 = 4,294,967,296` 个字节 = **约 4 GB**  

换算过程

```text
4,294,967,296 Byte ÷ 1024 = 4,194,304 KB
4,194,304 KB ÷ 1024 = 4,096 MB
4,096 MB ÷ 1024 = 4 GB
